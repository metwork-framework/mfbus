# General Configuration
daemon off;
worker_processes {{MFBUS_NGINX_WORKERS}};
{% if MFLOG_MINIMAL_LEVEL == "DEBUG" %}
error_log stderr debug;
{% else %}
error_log stderr error;
{% endif %}
pid        {{MFMODULE_RUNTIME_HOME}}/var/nginx.pid;

# Main Loop Configuration
events {
    worker_connections  40000;
}

# HTTP Configuration
http {

    include       {{MFMODULE_RUNTIME_HOME}}/tmp/config_auto/mime.types;
    default_type  text/plain;
    # FIXME: ugly hack with ~~~1 and ~~~~2 to circumvent nginxfmt problem with JSON
    log_format main '~~~1 "@timestamp": "$time_iso8601", "from": "$remote_addr", "method": "$request_method", "uri": "$request_uri", "duration": $request_time, "status": $status, "request_length": $request_length, "reply_length": $bytes_sent, "request_id": "$proxy_x_request_id" ~~~2';
    access_log /dev/stdout main;
    {% if MFBUS_NGINX_LOGGING == "1" %}
        {% if MFBUS_ADMIN_HOSTNAME != "null" %}
            {% if MFBUS_ADMIN_SEND_NGINX_LOGS == "1" %}
                access_log syslog:server=127.0.0.1:{{MFBUS_JSONSYSLOG2ELASTICSEARCH_NGINXLOG_PORT}} main;
            {% endif %}
        {% endif %}
    {% else %}
        access_log off;
    {% endif %}
    client_body_temp_path {{MFBUS_NGINX_CLIENTBODY_TEMP_PATH}};
    client_max_body_size {{MFBUS_NGINX_UPLOAD_MAX_BODY_SIZE}}m;

    {% if MFBUS_NGINX_ADD_REQUEST_ID_HEADER == "1" %}
    add_header X-Request-Id $proxy_x_request_id; # Return this header to client
    {% endif %}

    {% if MFBUS_NGINX_SERVER_TOKENS == "1" %}
        server_tokens on;
    {% else %}
        server_tokens off;
    {% endif %}

    lua_package_path '{{MFBUS_HOME}}/config/?.lua;{{MFBUS_HOME}}/lib/?.lua;;';
    lua_code_cache on;

    {% if MFBUS_NGINX_ACCEPT_INCOMING_REQUEST_ID_HEADER == "1" %}
        # If we receive X-Request-id header, use this value and not
        # a new generated request_id
        map $http_x_request_id $proxy_x_request_id {
            default $http_x_request_id;
            ''      $request_id;
        }
    {% else %}
        # As MFBUS_NGINX_ACCEPT_INCOMING_REQUEST_ID_HEADER == 0,
        # we generate a new request_id for each request
        map $http_x_request_id $proxy_x_request_id {
            default $request_id;
        }
    {% endif %}

    {% if MFBUS_NGINX_REAL_IP == "1" %}
        # realip feature
        # http://nginx.org/en/docs/http/ngx_http_realip_module.html
        real_ip_header {{MFBUS_NGINX_REAL_IP_HEADER}};
        {% if MFBUS_NGINX_REAL_IP_RECURSIVE == "1" %}
            real_ip_recursive on;
        {% else %}
            real_ip_recursive off;
        {% endif %}
        {% if MFBUS_NGINX_REAL_IP_SET_FROM and MFBUS_NGINX_REAL_IP_SET_FROM != "null" %}
            {% for ADDR in MFBUS_NGINX_REAL_IP_SET_FROM.split(',') %}
                {% if ADDR and ADDR != "null" %}
                    set_real_ip_from {{ADDR}};
                {% endif %}
            {% endfor %}
        {% endif %}
    {% endif %}

    server {

        listen unix:{{MFMODULE_RUNTIME_HOME}}/var/nginx.socket backlog=40000;
        {% if MFBUS_NGINX_PORT != "0" %}
        listen {{MFBUS_NGINX_PORT}} backlog=40000 default_server;
        {% endif %}
        {% if MFBUS_NGINX_HTTPS_PORT != "null" %}
        listen {{MFBUS_NGINX_HTTPS_PORT}} backlog=40000 ssl default_server;
        ssl_certificate {{MFBUS_NGINX_SSL_CERTIFICATE}};
        ssl_certificate_key {{MFBUS_NGINX_SSL_CERTIFICATE_KEY}};
        ssl_ciphers {{MFBUS_NGINX_SSL_CIPHERS}};
        ssl_protocols {{MFBUS_NGINX_SSL_PROTOCOLS}};
        {% endif %}
        server_name 127.0.0.1;

        location ~ ^/status$ {
            allow 127.0.0.1/32;
            deny all;
            stub_status on;
            access_log off;
        }

        # Monitoring service to avoid nginx worker zombies
        # FIXME: rename this in __uuid
        location = /uuid {
            allow 127.0.0.1/32;
            deny all;
            echo "{{UUID}}";
            access_log off;
        }

        set $tbs_storage_dir "{{MFBUS_TBS_STORAGE_DIR}}";

	    # Private service (upload)
		location ~ ^/__tbs_upload/(.*)$ {
			internal;
			access_log off;
			alias $tbs_storage_dir/$1;
			dav_methods PUT;
			create_full_put_path on;
			dav_access user:rw;
		}

        # Private service (download)
		location ~ ^/__tbs_download/(.*)$ {
			internal;
			access_log off;
			alias $tbs_storage_dir/$1;
		}

        # Private service (delete)
		location ~ ^/__tbs_delete/(.*)$ {
			internal;
			access_log off;
			dav_methods DELETE;
			alias $tbs_storage_dir/$1;
		}

        # Upload new blobs
        location ~ ^/tbs/(.*)/blobs$ {
	        client_body_buffer_size 16k;
	        client_max_body_size {{MFBUS_TBS_MAX_BLOB_SIZE}};
	        client_body_in_single_buffer on;
	        content_by_lua_block {
		        require("tbs").new_blob(ngx.var[1])
	        }
        }

        # Delete/read blobs
        location ~ ^/tbs/(.*)/blobs/(.*)$ {
	        content_by_lua_block {
		        local tbs = require("tbs")
				if ngx.var.request_method == "DELETE" then
					tbs.delete_blob(ngx.var[1], ngx.var[2])
				elseif ngx.var.request_method == "GET" then
					tbs.get_blob(ngx.var[1], ngx.var[2])
				else
					ngx.status=405
				end
			}
			log_by_lua_block {
				local tbs = require("tbs")
				tbs.after_get(ngx.var[1], ngx.var[2])
			}
		}

    }

}
